---- src/vue/index.ts ----
import { initializeExtension } from '../extension'

interface Plugin {
    install: (app: any, options: any) => void;
}

/**
 * This Vue 3 plugin provides the extension instance to all components.
 *
 * @example
 * import { createApp } from 'vue'
 * import { createExtension } from '@own3d/sdk/vue'
 * import App from './App.vue'
 *
 * const extension = createExtension()
 * const app = createApp(App)
 *
 * app.use(extension)
 * app.mount('#app')
 */
export function createExtension(): Plugin {
    const extension = initializeExtension()

    const install = (app: any, _options: any): void => {
        app.config.globalProperties.$extension = extension
        app.provide('extension', extension)
    }

    return {
        install,
    }
}

---- src/types.ts ----
/**
 * The extension object provides methods to interact with the extension supervisor.
 */
export interface Extension {
    on: (event: string, callback: (data: any) => void) => void;
    once: (event: string, callback: (data: any) => void) => void;
    postMessage: (event: string, data: any, callback?: (data: any) => void) => void;
    emit: (event: string, data: any) => void;
    user?: Authorized;
    context?: Context;
    axios: any;
    state: any;
}

/**
 * Represents a JSON object.
 */
export type JsonObject = {
    [key: string]: JsonValue;
};

/**
 * Represents a JSON array.
 */
export type JsonArray = Array<JsonValue>;

/**
 * Represents a JSON value.
 */
export type JsonValue = string | number | boolean | null | JsonArray | JsonObject;

/**
 * Represents a configuration segment key.
 */
export type ConfigSegmentKey = 'broadcaster' | 'developer' | 'global';

/**
 * Represents configuration segments.
 */
export type ConfigSegments = {
    [key in ConfigSegmentKey]: JsonObject;
};

/**
 * List of supported modes.
 */
export type Mode = 'widget' | 'standalone' | 'browser-source' | 'config';

/**
 * List of supported themes.
 */
export type Theme = 'dark' | 'light' | 'auto';

/**
 * Represents a user object.
 *
 * @deprecated Use Authorized instead.
 */
export interface User extends Authorized {
    // Deprecated
}

/**
 * Represents a Pro subscription object.
 */
export interface ProSubscription {
    features: string[];
}

/**
 * Represents a Cost object.
 */
export interface Cost {
    amount: number;
    type: 'coins';
}

/**
 * Represents a Product object.
 */
export interface Product {
    sku: string;
    name: string;
    cost: Cost;
    environment: string;
    recurrence: 'one-time' | 'weekly' | 'monthly' | 'yearly';
}

/**
 * Represents a Subscription object.
 */
export interface Subscription {
    id: string;
    status: 'active' | 'canceled';
    created_at: string;
    expires_at: string;
    canceled_at: string;
    cost: Cost;
}

/**
 * Represents a Metadata object.
 */
export interface Metadata {
    [key: string]: string;
}

/**
 * When a user decides to use coins, you will receive a Transaction object.
 */
export interface Transaction {
    id: string;
    client_id: string;
    user_id: string;
    channel_id: string;
    subscription: Subscription | null;
    product: Product;
    metadata: Metadata;
    status: 'pending' | 'completed' | 'canceled';
}

/**
 * When a user has authorized your extension, you will receive an Authorized object.
 */
export interface Authorized {
    client_id: string;
    client_token: string;
    channel_id: string;
    user_id: string;
    scopes: string[];
    token: string;
    mode: Mode;
}

/**
 * Each extension has a context object that contains information about the environment, language, mode, and theme.
 */
export interface Context {
    environment: string;
    language: string;
    mode: Mode;
    theme: Theme;

    [key: string]: any;
}

export interface NotifySubCondition {
    platform: string;
    platform_id: string;
}

export interface NotifySubSubscription {
    type: string;
    version: string;
    condition: NotifySubCondition;
}

export interface NotifySubNotification {
    id: string;
    created_at: string;
}

export type NotifySubEventPayload =
    | {} // For event types like "stream.online", "stream.offline", "update"
    | { name: string } // For "follow"
    | { name: string; tier: string; is_gift: boolean } // For "subscribe"
    | {
    name: string;
    message: string;
    emotes: any[];
    tier: string;
    months: number;
    streak: number;
    duration: number;
} // For "re-subscribe"
    | {
    gifter: string;
    tier: string;
    amount: number;
    cumulative_amount: number;
    is_anonymous: boolean;
} // For "gift-subscribe"
    | { name: string; amount: number; message: string } // For "cheer"
    | { name: string; count: number } // For "raid"
    | {
    name: string;
    message: string;
    tier: string;
    currency: string;
    amount: string;
} // For "superchat"
    | {
    name: string;
    sticker: string;
    tier: string;
    currency: string;
    amount: string;
} // For "supersticker"
    | { name: string; url: string } // For "shoutout.create" and "shoutout.receive"
    | { level: number } // For "hype_train.begin"
    | {
    name: string;
    campaign_id: string;
    charity_name: string;
    charity_description: string;
    charity_website: string;
    charity_logo: string;
    currency: string;
    amount: string;
} // For "charity-donation"
    | { id: string } // For "custom reward" add, update, remove
    | {
    id: string;
    name: string;
    message: string;
    status: string;
    user_id: string;
    user_login: string;
    user_name: string;
    user_input: string;
    broadcaster_id: string;
    broadcaster_login: string;
    broadcaster_name: string;
    reward_id: string;
    reward_title: string;
    reward_cost: number;
    reward_prompt: string;
}; // For "custom reward redemption" add, update

export interface NotifySub {
    subscription: NotifySubSubscription;
    notification: NotifySubNotification;
    event: NotifySubEventPayload;
}


---- src/support/index.ts ----
// noinspection JSUnusedGlobalSymbols

import * as WebFont from "webfontloader";

interface BorderRadius {
    multiple: boolean;
    radius: number;
    "top-left": number;
    "top-right": number;
    "bottom-left": number;
    "bottom-right": number;
}

interface FontSettings {
    "font-color": string;
    "font-family": string;
    "font-weight": number;
    "font-size": number;
    "text-align": string;
    "font-style": string;
    "letter-spacing": number;
    "line-height": number;
    "text-indent": number;
    "font-casing": string;
}

type CssValue = string | number | undefined;

interface CssProperties {
    [key: string]: CssValue;
}

export function textStyle(
    fontSettings: FontSettings | undefined | null,
    transformer: { [key: string]: (x: CssValue) => CssValue } = {},
): CssProperties {
    const modifiers: {
        [key: string]: {
            default: CssValue;
            suffix: string | null;
            id: keyof FontSettings;
        };
    } = {
        color: { default: "#fffff", suffix: null, id: "font-color" },
        fontFamily: { default: "Inter", suffix: null, id: "font-family" },
        fontWeight: { default: 400, suffix: null, id: "font-weight" },
        fontSize: { default: 14, suffix: "px", id: "font-size" },
        textAlign: { default: "left", suffix: null, id: "text-align" },
        fontStyle: { default: "normal", suffix: null, id: "font-style" },
        letterSpacing: { default: 0, suffix: "px", id: "letter-spacing" },
        lineHeight: { default: 1.2, suffix: null, id: "line-height" },
        textIndent: { default: 0, suffix: "px", id: "text-indent" },
        textTransform: { default: "none", suffix: null, id: "font-casing" },
    };

    const style: CssProperties = {};

    // check if modifier exists in values and if not set default value
    Object.keys(modifiers).forEach((modifierKey) => {
        const modifier = modifiers[modifierKey];
        let value = fontSettings?.[modifier.id];

        if (transformer[modifier.id]) {
            value = transformer[modifier.id](value);
        }

        if (modifier.suffix) {
            style[modifierKey] = value
                ? value + modifier.suffix
                : modifier.default + modifier.suffix;
        } else {
            style[modifierKey] = value ? value : modifier.default;
        }
    });

    return style;
}

export function radius(
    borderRadius: BorderRadius | undefined | null,
): CssProperties {
    if (!borderRadius) {
        return {};
    }
    if (borderRadius.multiple) {
        return {
            borderTopLeftRadius: `${borderRadius["top-left"]}px`,
            borderTopRightRadius: `${borderRadius["top-right"]}px`,
            borderBottomRightRadius: `${borderRadius["bottom-left"]}px`,
            borderBottomLeftRadius: `${borderRadius["bottom-right"]}px`,
        };
    }

    return {
        borderRadius: `${borderRadius["radius"]}px`,
    };
}

export function checked(
    input: Array<string> | Record<string, unknown>,
    key: string,
): boolean {
    if (Array.isArray(input)) {
        return input.includes(key);
    }

    return input[key] === true;
}

const cachedFonts: CssValue[] = [];

export function loadFont(fontFamily: CssValue): void {
    if (!fontFamily || cachedFonts.includes(fontFamily)) {
        return;
    }

    WebFont.load({
        google: {
            families: [`${fontFamily}:100,200,300,400,500,600,700,800,900`],
            api: "https://fonts.bunny.net/css",
        },
        fontloading: (familyName: string) => {
            cachedFonts.push(familyName);
        },
        classes: false,
    });
}

export function lazyLoadFont(object: CssProperties): CssProperties {
    if (object.fontFamily) {
        loadFont(object.fontFamily);
    }
    return object;
}


---- src/subscription/index.ts ----
import type { Extension } from '../types'
import { useIpc } from '../ipc/index'

interface ProSubscriptionUpsellOptions {
  firstpromoter?: {
    slug?: string
  }
}

interface SubscriptionComposable {
  showProSubscriptionUpsell: (options: ProSubscriptionUpsellOptions) => void
}

/**
 * The Subscription module provides methods to the Subscription.
 *
 * @param extension - The extension instance
 *
 * @example
 * import { initializeExtension } from '@own3d/sdk/extension'
 * import { useSubscription } from '@own3d/sdk/subscription'
 *
 * const extension = initializeExtension()
 *
 * const { showProSubscriptionUpsell } = useSubscription(extension)
 *
 * showProSubscriptionUpsell({
 *  firstpromoter: {
 *   slug: 'my-slug',
*   }
 * })
 */
export function useSubscription(extension: Extension): SubscriptionComposable {
  const { send } = useIpc(extension)

  function showProSubscriptionUpsell(options: any) : void {
    send('own3d.pro/show-pro-sub-upsell', options)
  }

  return {
    showProSubscriptionUpsell,
  }
}

---- src/ipc/index.ts ----
import type { Extension } from '../types.ts'

interface IpcComposable {
    send: (channel: string, payload: any) => void,
    invoke: (channel: string, payload: any) => Promise<any>
    on: (channel: string, callback: (payload: any) => void) => void
}

/**
 * The Ipc module provides methods to send and receive messages between the extension and the overlay.
 * Avoid using our internal IPC module for communication between different parts of your extension.
 * Instead, use the PubSub module. IPC is only intended for communication between the extension and the OWN3D platform.
 *
 * @param extension - The extension instance
 *
 * @example
 * import { initializeExtension } from '@own3d/sdk/extension'
 * import { useIpc } from '@own3d/sdk/ipc'
 *
 * const extension = initializeExtension()
 *
 * const { send, invoke } = useIpc(extension)
 *
 * send('channel', { key: 'value' })
 *
 * invoke('channel', { key: 'value' }).then((data) => {
 *    console.log(data)
 * })
 */
export function useIpc(extension: Extension): IpcComposable {
    const send = function (channel: string, payload: any) {
        extension.postMessage('ipc', {channel, payload})
    }

    const invoke = function (channel: string, payload: any): Promise<any> {
        return new Promise((resolve) => {
            extension.postMessage('ipc', {channel, payload}, (data) => resolve(data))
        })
    }

    const on = function (channel: string, callback: (payload: any) => void) {
        extension.on('ipc', ({channel: _channel, payload}) => {
            if (_channel === channel) {
                callback(payload)
            }
        })
    }

    return {
        send,
        invoke,
        on,
    }
}

---- src/notifications/index.ts ----
import type { Extension } from '../types'
import { useIpc } from '../ipc/index'

interface NotificationsComposable {
    notify: (content: Notification) => Promise<NotificationResponse>
    dismiss: (id: string) => Promise<NotificationResponse>
    patch: (id: string, content: Notification) => Promise<NotificationResponse>
    info: (content: string | Notification) => Promise<NotificationResponse>
    success: (content: string | Notification) => Promise<NotificationResponse>
    warning: (content: string | Notification) => Promise<NotificationResponse>
    error: (content: string | Notification) => Promise<NotificationResponse>
}

interface Notification {
    id?: string
    type: 'info' | 'success' | 'warning' | 'error'
    title?: string
    message: string
}

interface NotificationResponse {
    id: string
    success: boolean
}

/**
 * The Notifications module provides api methods to send notifications to the user.
 */
export function useNotifications(extension: Extension): NotificationsComposable {
    const {invoke} = useIpc(extension)

    const notify = function (content: Notification): Promise<NotificationResponse> {
        return invoke('scene-builder.own3d.pro/notification', {content})
    }

    const dismiss = function (id: string): Promise<NotificationResponse> {
        return invoke('scene-builder.own3d.pro/dismiss-notification', {id})
    }

    const patch = function (id: string, content: Notification): Promise<NotificationResponse> {
        return invoke('scene-builder.own3d.pro/patch-notification', {id, content})
    }

    const info = function (content: string | Notification): Promise<NotificationResponse> {
        if (typeof content === 'string') {
            return notify({type: 'info', message: content})
        } else {
            return notify({...content, type: 'info'})
        }
    }

    const success = function (content: string | Notification): Promise<NotificationResponse> {
        if (typeof content === 'string') {
            return notify({type: 'success', message: content})
        } else {
            return notify({...content, type: 'success'})
        }
    }

    const warning = function (content: string | Notification): Promise<NotificationResponse> {
        if (typeof content === 'string') {
            return notify({type: 'warning', message: content})
        } else {
            return notify({...content, type: 'warning'})
        }
    }

    const error = function (content: string | Notification): Promise<NotificationResponse> {
        if (typeof content === 'string') {
            return notify({type: 'error', message: content})
        } else {
            return notify({...content, type: 'error'})
        }
    }

    return {
        notify,
        dismiss,
        patch,
        info,
        success,
        warning,
        error,
    }
}

---- src/pubsub/index.ts ----
import type {Extension} from "../types.ts";

interface PubSubComposable {
    publish: (event: string, data: any) => Promise<void>,
    subscribe: (event: string, callback: (data: any) => void) => void
}

/**
 * The Socket module provides methods to connect to our event bus, which is a real-time messaging system
 * that allows you to receive events from the OWN3D platform. For example, you can listen for events like
 * new subscriptions or donations via our NotifySub Event Types or custom events. You can also use the
 * Socket module to receive events from the extension itself, like Remote Config changes.
 *
 * @param extension - The extension instance
 *
 * @example
 * import { initializeExtension } from '@own3d/sdk/extension'
 * import { useSocket } from '@own3d/sdk/socket'
 *
 * const extension = initializeExtension()
 *
 * const { on } = useSocket(extension)
 *
 * on('notifysub', (data) => {
 *     console.log(data)
 * })
 */
export function usePubSub(extension: Extension): PubSubComposable {
    return {
        publish: async (event: string, data: any) => {
            await extension.axios.post('https://ext.own3d.pro/v1/pubsub', {
                event,
                data,
            })
        },
        subscribe: (event: string, callback: (data: any) => void) => {
            extension.on('socket', ({event: _event, data}) => {
                if (_event === 'pubsub' && data.event === event) {
                    callback(data)
                }
            })
        },
    }
}

---- src/socket/index.ts ----
import type {Extension} from "../types.ts";

interface SocketComposable {
    on: (event: string, callback: (data: any) => void) => void
}

/**
 * The Socket module provides methods to connect to our event bus, which is a real-time messaging system
 * that allows you to receive events from the OWN3D platform. For example, you can listen for events like
 * new subscriptions or donations via our NotifySub Event Types or custom events. You can also use the
 * Socket module to receive events from the extension itself, like Remote Config changes.
 *
 * @param extension - The extension instance
 *
 * @example
 * import { initializeExtension } from '@own3d/sdk/extension'
 * import { useSocket } from '@own3d/sdk/socket'
 *
 * const extension = initializeExtension()
 *
 * const { on } = useSocket(extension)
 *
 * on('notifysub', (data) => {
 *     console.log(data)
 * })
 */
export function useSocket(extension: Extension): SocketComposable {
    const on = (event: string, callback: (data: any) => void): void => {
        extension.on(`socket`, (data) => data.event === event ? callback(data.data) : null)
    }

    return {
        on
    }
}

---- src/remote-config/index.ts ----
import axios, { type AxiosResponse } from 'axios'
import type { ConfigSegmentKey, ConfigSegments, Extension, JsonObject } from '../types.ts'

interface RemoteConfigComposable {
    getSegments: () => Promise<ConfigSegments>,
    setSegment: (segment: ConfigSegmentKey, content: JsonObject) => Promise<void>
}

/**
 * The Remote Config module provides methods to get and set configuration values without providing a backend service.
 * Make sure to check out our Remote Config documentation for more information.
 *
 * @param extension - The extension instance
 *
 * @example
 * import { initializeExtension } from '@own3d/sdk/extension'
 * import { useRemoteConfig } from '@own3d/sdk/remote-config'
 *
 * const extension = initializeExtension()
 *
 * const { getSegments, setSegment } = useRemoteConfig(extension)
 *
 * const segments = await getSegments()
 * console.log(segments)
 *
 * await setSegment('creator', { key: 'value' })
 */
export function useRemoteConfig(extension: Extension): RemoteConfigComposable {
    const _axios = axios.create({
        baseURL: 'https://ext.own3d.pro/',
        headers: {
            'Content-Type': 'application/json',
        },
    })

    const getSegments = async function (): Promise<ConfigSegments> {
        const response: AxiosResponse<ConfigSegments> = await _axios.get('v1/remote-configs/segments', {
            headers: {
                Authorization: `Bearer ${extension.user?.token}`,
            },
        })

        return response.data
    }

    const setSegment = async function (segment: ConfigSegmentKey, content: JsonObject): Promise<void> {
        await _axios.patch(`v1/remote-configs/segments`, {
            [segment]: content,
        }, {
            headers: {
                Authorization: `Bearer ${extension.user?.token}`,
            },
        })
    }

    return {
        getSegments,
        setSegment,
    }
}

---- src/scene-builder/index.ts ----
import type { Extension } from '../types'
import { useIpc } from '../ipc/index'

interface SceneBuilderComposable {
    setInteractive: (interactive: boolean) => Promise<void>
    onClick: (inputId: string, callback: () => void) => void
    setValues: (values: Record<string, string>) => Promise<void>
    patchValues: (values: Record<string, string>) => Promise<void>
}

/**
 * The SceneBuilder module provides methods to the Scene Builder.
 *
 * @param extension - The extension instance
 *
 * @example
 * import { initializeExtension } from '@own3d/sdk/extension'
 * import { useSceneBuilder } from '@own3d/sdk/scene-builder'
 *
 * const extension = initializeExtension()
 *
 * const { setInteractive } = useSceneBuilder(extension)
 *
 * setInteractive(true)
 */
export function useSceneBuilder(extension: Extension): SceneBuilderComposable {
    const {invoke, on} = useIpc(extension)

    const setInteractive = function (interactive: boolean) : Promise<void> {
        return invoke('scene-builder.own3d.pro/interactive', {interactive})
    }

    const onClick = function (inputId: string, callback: () => void) {
        on(`scene-builder.own3d.pro/click/${inputId}`, callback)
    }

    const setValues = function (values: Record<string, string>): Promise<void> {
        return invoke('scene-builder.own3d.pro/set-values', {values})
    }

    const patchValues = function (values: Record<string, string>): Promise<void> {
        return invoke('scene-builder.own3d.pro/patch-values', {values})
    }

    return {
        setInteractive,
        onClick,
        setValues,
        patchValues,
    }
}

---- src/auth/index.ts ----
import type { Authorized, Extension } from '../types.ts'

interface AuthComposable {
    onAuthorized: (authCallback: (auth: Authorized) => void) => void
}

/**
 * The Auth module provides methods to authenticate the extension with the OWN3D platform.
 * It allows you to get the current authenticated user and listen for changes to the authentication state.
 *
 * @param extension - The extension instance
 *
 * @example
 * import { initializeExtension } from '@own3d/sdk/extension'
 * import { useAuth } from '@own3d/sdk/auth'
 *
 * const extension = initializeExtension()
 *
 * const { onAuthorized } = useAuth(extension)
 *
 * onAuthorized(async (user) => {
 *     console.log(user)
 * })
 */
export function useAuth(extension: Extension): AuthComposable {
    const onAuthorized = (authCallback: (auth: Authorized) => void): void => {
        extension.postMessage('authorized', {}, (data) => authCallback(data))
    }

    return {onAuthorized}
}

---- src/extension/index.ts ----
import axios from 'axios'
import { useAuth } from '../auth/index'
import { useContext } from '../context/index'
import type { Authorized, Context, Extension } from '../types.ts'
import { JSONRPCClient, JSONRPCServer, JSONRPCServerAndClient } from 'json-rpc-2.0'

let _callbackCounter = 0
// deno-lint-ignore prefer-const
let _observers: { [key: string]: ((data: any) => void)[] } = {}
// deno-lint-ignore prefer-const
let _callbacks: { [key: string]: (data: any) => void } = {}
const _state = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15)
const _axios = axios.create({
    baseURL: 'https://ext.own3d.pro/',
    headers: {
        'Content-Type': 'application/json',
    },
})
const _jsonRpc = new JSONRPCServerAndClient(
    new JSONRPCServer(),
    new JSONRPCClient((request) => {
        // @ts-ignore
        parent.postMessage(request, '*')
        return Promise.resolve()
    }),
)

/**
 * This variable is used to determine whether the extension should use JSON-RPC for communication.
 * In future versions, this variable will be set to true by default.
 */
const useJsonRpc: boolean = false

function emit(event: string, data: any) {
    if (event in _observers) {
        for (const observer of _observers[event]) {
            observer(data)
        }
    }
}

function on(event: string, callback: (data: any) => void) {
    // push callback to observers
    if (!_observers[event]) {
        _observers[event] = []
    }
    _observers[event].push(callback)
}

function once(event: string, callback: (data: any) => void) {
    // push callback to observers
    if (!_observers[event]) {
        _observers[event] = []
    }
    _observers[event].push((data) => {
        callback(data)
        _observers[event].splice(_observers[event].indexOf(callback), 1)
    })
}

function postMessage(event: string, data: any, callback?: (data: any) => void) {
    if (useJsonRpc) {
        if (callback) {
            _jsonRpc.request(event, data).then((result) => callback(result))
        } else {
            _jsonRpc.notify(event, data)
        }
    } else {
        const message: {
            event: string;
            data: any;
            callbackId: string | null;
        } = {event, data, callbackId: null}

        if (callback) {
            const callbackId = 'cb_' + (++_callbackCounter)
            _callbacks[callbackId] = callback
            message.callbackId = callbackId
        }

        // @ts-ignore
        parent.postMessage(message, '*')
    }
}

window.addEventListener('message', async function (e: any) {
    // Check if the message originated from the same origin
    // @ts-ignore
    if (e.origin === window.origin) {
        // Ignore the message
        return
    }
    // Handle JSON-RPC messages
    if (typeof e.data === 'object' && 'jsonrpc' in e.data) {
        await _jsonRpc.receiveAndSend(e.data)
        return
    }

    // Handle legacy messages
    const {event, data, callbackId} = e.data
    if (event === 'callback' && _callbacks[callbackId]) {
        _callbacks[callbackId](data)
        delete _callbacks[callbackId]
    } else {
        emit(event, data)
    }
})

window.addEventListener('beforeunload', function () {
    _jsonRpc.rejectAllPendingRequests(
        'Extension is being unloaded',
    )
    postMessage('beforeunload', {state: _state})
})

window.addEventListener('load', function () {
    postMessage('load', {state: _state, version: 2, jsonrpc: useJsonRpc})
    _jsonRpc
        .request('echo', {text: 'jsonrpc echo test'})
        .then((result) => console.log(result))
})

const extension = {
    on,
    once,
    postMessage,
    emit,
    axios: _axios,
    state: _state,
    user: {},
    context: {},
} as Extension

const {onAuthorized} = useAuth(extension)
const {onContext} = useContext(extension)

/**
 * Internal listener for the authorization event, which is triggered by the extension
 */
onAuthorized((data: Authorized) => {
    _axios.defaults.headers.common['Authorization'] = `Bearer ${data.token}`
    extension.user = {...extension.user, ...data} as Authorized
})

/**
 * Internal listener for the context event, which is triggered by the extension
 */
onContext((context, changed) => {
    for (const key of changed) {
        extension.context = {...extension.context, [key]: context[key]} as Context
    }
})

/**
 * Returns the current extension instance. In future versions, this method will be used to initialize the
 * extension instance when working without the supervisor.
 *
 * @returns The extension instance
 */
export const initializeExtension = (): Extension => {
    return extension
}


---- src/coins/index.ts ----
import type { Extension, Metadata, Transaction } from '../types.ts'

interface CoinsComposable {
    getProducts: () => Promise<any>,
    showCoinsBalance: () => void,
    useCoins: (sku: string, metadata: Metadata) => Promise<Transaction>,
    onTransactionComplete: (callback: (transaction: Transaction) => void) => void,
    onTransactionCancelled: (callback: (transaction: Transaction) => void) => void
}

/**
 * The Coins module provides methods to get products, show the coins balance, use coins and
 * listen for transaction events.
 *
 * @param extension
 *
 * @example
 * import { initializeExtension } from '@own3d/sdk/extension'
 * import { useCoins } from '@own3d/sdk/coins'
 *
 * const extension = initializeExtension()
 *
 * const { getProducts } = useCoins(extension)
 *
 * getProducts().then((products) => {
 *    console.log(products)
 * })
 */
export function useCoins(extension: Extension): CoinsComposable {
    const getProducts = function () {
        return new Promise((resolve) => {
            extension.postMessage('get-products', {}, (data) => resolve(data))
        })
    }

    const showCoinsBalance = function () {
        extension.postMessage('show-coins-balance', {})
    }

    const useCoins = function (sku: string, metadata: Metadata): Promise<Transaction> {
        return new Promise((resolve) => {
            extension.postMessage('use-coins', {sku, metadata}, (data) => resolve(data))
        })
    }

    const onTransactionComplete = function (callback: (transaction: Transaction) => void) {
        extension.on('transaction-complete', (data) => callback(data))
    }

    const onTransactionCancelled = function (callback: (transaction: Transaction) => void) {
        extension.on('transaction-cancelled', (data) => callback(data))
    }


    return {
        getProducts,
        showCoinsBalance,
        useCoins,
        onTransactionComplete,
        onTransactionCancelled,
    }
}

---- src/context/index.ts ----
import type { Context, Extension } from '../types.ts'

interface ContextComposable {
    onContext: (
        contextCallback: <T extends Partial<Context>>(context: T, changed: ReadonlyArray<keyof T>) => void,
        options?: { immediate: boolean } | undefined,
    ) => void
}

/**
 * The Context module provides methods to get the current context of the extension.
 *
 * @param extension - The extension instance
 *
 * @example
 * import { initializeExtension } from '@own3d/sdk/extension'
 * import { useContext } from '@own3d/sdk/context'
 *
 * const extension = initializeExtension()
 *
 * const { onContext } = useContext(extension)
 *
 * onContext((context, changed) => {
 *     console.log(context, changed)
 * })
 */
export function useContext(extension: Extension): ContextComposable {
    const onContext = (
        contextCallback: <T extends Partial<Context>>(context: T, changed: ReadonlyArray<keyof T>) => void,
        options?: { immediate: boolean } | undefined,
    ): void => {
        if (options?.immediate) {
            contextCallback(extension.context as Context, Object.keys(extension.context as Context) as (keyof Context)[])
        }
        extension.on('context', (data) => contextCallback(data.context, data.changed))
    }

    return {
        onContext,
    }
}

